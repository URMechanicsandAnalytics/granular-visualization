import math
import numpy as np
from granular_vis.granular_bed.profiles import BedProfile


class Bed:
    """
    Class to apply conditions on the initial particle bed
    """

    def __init__(self, bed_snap: dict):
        """
        get the timeDict generated by the Bed-ish class
        """
        self.__bed_snap: dict = bed_snap

    def make_profile(self):

        """
        Method that returns a profile object based on the conditions passed in.
            - `condition_bed` : a list of indices that satisfy a certain condition
            - Returns : `P_Profile` object
        """
        condition_bed = self.is_greater('y', 0.14)

        return BedProfile(
            np.array([
                [v for k, v in self.get_data('x').items() if k in condition_bed],
                [v for k, v in self.get_data('y').items() if k in condition_bed],
                [v for k, v in self.get_data('r').items() if k in condition_bed]
            ]).T
        )

    def get_input(self):
        """
        Method to get access to the input dictionary
        """
        return self.__bed_snap

    def get_data(self, parameter: str, as_array: bool = False):
        """
        Method to get a dictionary that only includes data of the parameter passed in
        """
        # checking if the input parameter is correct
        if parameter not in list(next(iter(self.__bed_snap.items()))[1].keys()):
            raise KeyError("Input parameter was not found.")

        if as_array:
            return [v[parameter] for v in iter(self.__bed_snap.values())]

        return {k: v[parameter] for k, v in self.__bed_snap.items()}

    def get_surface(self) -> list[int]:
        """
        Returns a list of particle IDs for the surface particles
        """

        # * looking at the particles higher than 80% of the max height --> that is where the surface would be

        profile = self.make_profile()

        # looping through the dictionary to find the surface partices
        for key in self.__bed_snap:
            self.__bed_snap[key]['surface'] = profile.p_is_surface(self.__bed_snap[key]['x'], self.__bed_snap[key]['y'])

        return [k for k, v in self.__bed_snap.items() if v['surface'] == 1]

    # * conditionals
    def is_greater(self, parameter: str, val: float) -> list[int]:
        """
        Returns a list of particle IDs for which the values for the specified parameters are 
        greater than the value passed in
        """
        return [k for k, v in self.__bed_snap.items() if v[parameter] > val]

    def is_lesser(self, parameter: str, val: float) -> list[int]:
        """ 
        Returns a list of particle IDs for which the values for the specified parameters are 
        lesser than the value passed in
        """
        return [k for k, v in self.__bed_snap.items() if v[parameter] < val]

    def is_within(self, parameter: str, low: float, high: float) -> list[int]:
        """
        Returns a list of particle IDs for which the values for the specified parameters are 
        within the high and the low values passed in
        """
        return [k for k, v in self.__bed_snap.items() if (low < v[parameter] < high)]

    def is_within_2d(self, left: float, right: float, down: float, up: float) -> list[int]:
        """
        Returns a list of particle IDs for which the values for the specified parameters are 
        within the range of values passed in
        """

        return [k for k, v in self.__bed_snap.items() if ((left < v['x'] < right) and (down < v['y'] < up))]

    def is_within_circle(self, origin: tuple[float, float], radius: float) -> list[int]:
        """
        Returns a list of particle IDs within a circular region defined by the arguments
            - Arguments:
                - `origin` : the center point of the circular region. Must be in the form (x,y)
                - `radius` : the radius of the circular region    
        """

        return [k for k, v in self.__bed_snap.items() if math.dist([v['x'], v['y']], [*origin]) < radius]

    def is_within_circle_region(self, origin: tuple[float, float],
                                radius_inner: float, radius_outer: float) -> list[int]:
        """
        Returns a list of particle IDs within a circular region defined by the arguments
            - Arguments:
                - `origin` : the center point of the circular region. Must be in the form (x,y)
                - `radius_outer` : the outer radius of the circular region
                - `radius_inner` : the inner radius of the circular region
        """

        return [k for k, v in self.__bed_snap.items() if
                radius_inner < math.dist([v['x'], v['y']], [*origin]) < radius_outer]

    def is_array_surface(self, array: list[float]) -> list[int]:
        """
        Returns a list of particle IDs for which the values of the surface particles are
        closest to the coordinates in the array passed in.
            - Arguments:
                - `array` : a list of coordinate values that the particles should be found in on the surface
        """

        # getting a dictionary for the surface particles
        # surfaceDict = { k:v for k,v in self.__bed_snap.items() if k in self.get_surface()}
        surface_idx = self.get_surface()

        target_idx = []
        for point in array:
            target_idx.append(
                # min( self.get_surface(), key = lambda i: abs(point - self.__bed_snap[i]['x']) )
                min(surface_idx, key=lambda i: abs(point - self.__bed_snap[i]['x']))
            )

        return target_idx

    def is_array(self, direction: str, array: list[float], hold: float) -> list[int]:
        """
        Returns a list of particle IDs for which the values of the particles are
        closest to the coordinates in the array passed in
            - Arguments:
                - `direction` : character argument specifying wheter or not the array of particles is horizontal or vertical
                    - `'h'` for horizontal, `'v'` for vertical
                - `array` : list of coordinate values that the particles should be found in
                - `hold` : the single position that the particles would share
        """

        # todo make this different for different directions
        mins_idx = []
        if direction == 'h':
            reduced_search = self.is_within('y', hold - 0.01, hold + 0.01)

            for point in array:
                mins_idx.append(
                    min(reduced_search,
                        key=lambda i: math.dist((point, hold), (self.__bed_snap[i]['x'], self.__bed_snap[i]['y'])))
                )
        if direction == 'v':
            reduced_search = self.is_within('x', hold - 0.01, hold + 0.01)
            for point in array:
                mins_idx.append(
                    min(reduced_search,
                        key=lambda i: math.dist((hold, point), (self.__bed_snap[i]['x'], self.__bed_snap[i]['y'])))
                )

        return mins_idx

    def is_mesh(self, array_x: list[float], array_y: list[float]) -> list[int]:
        """
        Returns a list of particle IDs for which the values of the particles are
        closest to in the given mesh passed in
        """

        # todo Call the self.is_array function multiple times I guess...

        pass
